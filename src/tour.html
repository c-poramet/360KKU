<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>360Â° Virtual Tour</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pannellum@2.5.6/build/pannellum.css"/>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/pannellum@2.5.6/build/pannellum.js"></script>
    <!-- Leaflet.js CSS and JS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" 
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" 
        crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
        crossorigin=""></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100vh;
            overflow: hidden;
            background-color: #000;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }
        #panorama {
            width: 100%;
            height: 100%;
        }
        #floorplan-container {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px; /* Fixed width for square shape */
            height: 200px; /* Fixed height to match width */
            border: 2px solid rgba(255, 255, 255, 0.7);
            border-radius: 8px;
            overflow: hidden;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
        }
        #minimap {
            width: 100%;
            height: 100%;
        }
        /* Custom Leaflet marker styles */
        .scene-marker-icon {
            border-radius: 50%;
            border: 2px solid white !important;
            background-color: #ff4500 !important; /* Orange-red color */
            box-shadow: 0 0 8px rgba(0, 0, 0, 0.7) !important;
            transition: all 0.3s ease;
            z-index: 1000 !important; /* Ensure markers are on top */
            /* Override any Leaflet default styles */
            margin: 0 !important;
            padding: 0 !important;
        }
        .scene-marker-icon.active {
            background-color: #00ff7f !important; /* Bright green for active marker */
            border-color: white !important;
            box-shadow: 0 0 15px #00ff7f !important;
            transform: scale(1.5);
            z-index: 1001 !important; /* Active marker is above others */
        }
        /* Special styling for known markers */
        .lcorr1-marker {
            background-color: #FF6347 !important; /* Tomato */
        }
        .lcorr2-marker {
            background-color: #4682B4 !important; /* SteelBlue */
        }
        .lcorr1-marker.active, .lcorr2-marker.active {
            background-color: #32CD32 !important; /* LimeGreen */
        }
        /* Fix for Leaflet default marker z-index and styling issues */
        .leaflet-marker-icon {
            z-index: 1000 !important;
            background-color: #ff4500 !important;
            border-radius: 50% !important;
            border: 2px solid white !important;
        }
        .leaflet-marker-icon.active {
            z-index: 1001 !important;
            background-color: #00ff7f !important;
        }
        /* Ensure proper sizing for the marker icon div */
        .leaflet-div-icon {
            width: 14px !important;
            height: 14px !important;
            background-color: #ff4500 !important;
            border: 2px solid white !important;
            border-radius: 50% !important;
        }
        /* Override Leaflet's default styles for our dark theme */
        .leaflet-container {
            background: rgba(0, 0, 0, 0.6) !important;
        }
        .leaflet-control-attribution {
            background: rgba(0, 0, 0, 0.5) !important;
            color: #aaa !important;
            font-size: 8px !important;
        }
        .pnlm-hotspot {
            width: 30px !important;
            height: 30px !important;
            border-radius: 50%;
            background: rgba(59, 130, 246, 0.8) !important;
            border: 2px solid white !important;
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.7);
            opacity: 1 !important;
            visibility: visible !important;
        }
        .pnlm-hotspot:hover {
            box-shadow: 0 0 25px rgba(59, 130, 246, 1);
        }
    </style>
</head>
<body>

    <div id="panorama"></div>
    <div id="floorplan-container">
        <div id="minimap"></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            let viewer;
            let tourConfig;
            let currentFloor = 'floor1'; // Default floor
            let map; // Leaflet map
            let markers = {}; // Store markers by sceneId
            let activeMarker; // Currently active marker
            let floorplanImage; // Current floor plan image overlay

            async function loadTour() {
                try {
                    const response = await fetch('tour-config.json');
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    tourConfig = await response.json();
                    console.log('Tour configuration loaded:', tourConfig);
                    initializeViewer(tourConfig);
                    initializeMap();
                    await loadFloorPlan(currentFloor);
                } catch (error) {
                    console.error("Could not load tour configuration:", error);
                    document.getElementById('panorama').innerText = 'Error: Could not load tour. Please check console for details.';
                }
            }

            function initializeViewer(config) {
                const firstSceneId = config.default.firstScene || Object.keys(config.scenes)[0];
                
                viewer = pannellum.viewer('panorama', {
                    "default": {
                        "firstScene": firstSceneId,
                        "sceneFadeDuration": config.default.sceneFadeDuration || 1000,
                        "autoLoad": true,
                        "compass": false,
                        "hotSpotDebug": false
                    },
                    "scenes": config.scenes
                });

                viewer.on('load', () => {
                    const currentSceneId = viewer.getScene();
                    updateActiveMarker(currentSceneId);
                });
                
                // Add scene change event listener to update the active marker
                viewer.on('scenechange', (sceneId) => {
                    console.log(`Scene changed to: ${sceneId}`);
                    updateActiveMarker(sceneId);
                });
            }
            
            function initializeMap() {
                // Create a Leaflet map with no initial view (we'll set it later)
                map = L.map('minimap', {
                    crs: L.CRS.Simple, // Use simple coordinate system for our floorplan
                    minZoom: -2,
                    maxZoom: 2,
                    zoomControl: false, // Hide zoom controls
                    attributionControl: false, // Hide attribution
                    doubleClickZoom: false, // Disable double click zoom
                    dragging: false // Disable dragging to keep the minimap fixed
                });
                
                // Add attribution in a more subtle way
                map.attributionControl = L.control.attribution({
                    prefix: 'Leaflet'
                }).addTo(map);
                
                // Define calibration points for coordinate transformation
                // These are reference points that map SVG coordinates to Leaflet coordinates
                // Based on your screenshot, we'll define these points for proper alignment
                map.calibrationPoints = {
                    // These are examples and need to be adjusted based on your actual data
                    // Format: [SVG coordinates] => [Leaflet coordinates]
                    // The green dot in your image is our reference point
                    svgToLeaflet: [
                        { svg: [536, 483], leaflet: [0.2, 0.8] }, // Green dot position
                        { svg: [576, 483], leaflet: [0.2, 0.85] } // Orange dot position
                    ]
                };
            }

            async function loadFloorPlan(floor) {
                try {
                    // Clear existing markers first
                    Object.values(markers).forEach(marker => {
                        try {
                            map.removeLayer(marker);
                        } catch (e) {
                            console.warn('Error removing marker:', e);
                        }
                    });
                    markers = {};
                    
                    // Remove existing floorplan image if any
                    if (floorplanImage) {
                        try {
                            map.removeLayer(floorplanImage);
                        } catch (e) {
                            console.warn('Error removing floorplan image:', e);
                        }
                    }
                    
                    // Function to load the image
                    const loadImage = async (url, type) => {
                        return new Promise((resolve, reject) => {
                            console.log(`Attempting to load ${type} floorplan from: ${url}`);
                            const img = new Image();
                            img.onload = function() {
                                console.log(`Loaded ${type} floorplan: ${this.width}x${this.height}`);
                                resolve({
                                    url: url,
                                    width: this.width,
                                    height: this.height,
                                    type: type
                                });
                            };
                            img.onerror = function() {
                                console.warn(`Could not load ${type} floor plan image`);
                                reject(new Error(`Could not load ${type} floor plan image`));
                            };
                            img.src = url;
                        });
                    };
                    
                    // Decide which image type to use based on the floor
                    let imgUrl, imgData;
                    
                    // Try to load PNG first (may provide better alignment)
                    try {
                        imgUrl = `images/${floor}/floorplan.png`;
                        imgData = await loadImage(imgUrl, 'png');
                        console.log('Successfully loaded PNG floorplan');
                    } catch (e) {
                        // If PNG fails, try SVG as fallback
                        try {
                            imgUrl = `images/${floor}/floorplan.svg`;
                            imgData = await loadImage(imgUrl, 'svg');
                            console.log('Falling back to SVG floorplan');
                        } catch (e2) {
                            throw new Error('Both PNG and SVG floorplan loading failed');
                        }
                    }
                    
                    console.log(`Loading ${imgData.type} floor plan: ${imgData.width}x${imgData.height}`);
                    
                    // Set map bounds based on image dimensions
                    const bounds = [[0, 0], [imgData.height, imgData.width]];
                    
                    // Store image information globally
                    window.floorplanInfo = {
                        type: imgData.type,
                        width: imgData.width,
                        height: imgData.height,
                        url: imgData.url
                    };
                    
                    console.log('Floor plan info:', window.floorplanInfo);
                    
                    // Reset the map view completely before adding new layers
                    if (map) {
                        try {
                            map.off();
                            map.remove();
                        } catch (e) {
                            console.warn('Error removing map:', e);
                        }
                    }
                    
                    // Re-initialize the map with improved configuration
                    map = L.map('minimap', {
                        crs: L.CRS.Simple,
                        minZoom: -2,
                        maxZoom: 2,
                        zoomControl: false,
                        attributionControl: false,
                        doubleClickZoom: false,
                        dragging: false,
                        fadeAnimation: true,
                        markerZoomAnimation: false,
                        inertia: false,
                        preferCanvas: true, // Use Canvas renderer for better performance
                        renderer: L.canvas(), // Explicitly set canvas renderer for markers
                        trackResize: true
                    });
                    
                    // Add a mousemove event to show coordinates for calibration
                    // This is helpful when trying to position markers manually
                    map.on('mousemove', function(e) {
                        // Calculate relative position (0-1)
                        const bounds = map.getBounds();
                        const mapWidth = bounds.getEast() - bounds.getWest();
                        const mapHeight = bounds.getNorth() - bounds.getSouth();
                        
                        const relX = (e.latlng.lng - bounds.getWest()) / mapWidth;
                        const relY = 1 - ((e.latlng.lat - bounds.getSouth()) / mapHeight); // Convert back from Leaflet's inverted Y
                        
                        // Update a global variable for debugging purposes
                        window.mousePosition = {
                            leaflet: { lat: e.latlng.lat, lng: e.latlng.lng },
                            relative: { x: relX, y: relY }
                        };
                    });
                    
                    // Add a click event for easy coordinate capture (useful for calibration)
                    map.on('click', function(e) {
                        // Calculate relative position (0-1)
                        const bounds = map.getBounds();
                        const mapWidth = bounds.getEast() - bounds.getWest();
                        const mapHeight = bounds.getNorth() - bounds.getSouth();
                        
                        const relX = (e.latlng.lng - bounds.getWest()) / mapWidth;
                        const relY = 1 - ((e.latlng.lat - bounds.getSouth()) / mapHeight);
                        
                        console.log(`Clicked at relative position: (${relX.toFixed(3)}, ${relY.toFixed(3)})`);
                        console.log(`For calibration, use: relX = ${relX.toFixed(3)}; relY = ${relY.toFixed(3)};`);
                        
                        // If in development mode, show an alert with the position
                        if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                            alert(`Position: (${relX.toFixed(3)}, ${relY.toFixed(3)})`);
                        }
                    });
                    
                    // Add the image overlay to the map with proper handling
                    floorplanImage = L.imageOverlay(imgUrl, bounds).addTo(map);
                    
                    // Store image dimensions and type
                    map.imgWidth = imgData.width;
                    map.imgHeight = imgData.height;
                    map.imgType = imgData.type;
                    
                    console.log(`Added ${imgData.type} floorplan to map: ${imgData.width}x${imgData.height}`);
                    
                    // Fit the map to the image bounds with a slight padding to ensure markers near edges are visible
                    map.fitBounds(bounds, {
                        padding: [5, 5], // 5px padding
                        animate: false   // No animation for initial fit
                    });
                    
                    // Wait a moment for the map to stabilize before adding markers
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    // Create markers for the scenes
                    try {
                        createMarkers(floor);
                    } catch (e) {
                        console.error('Error creating markers:', e);
                        throw e;
                    }
                    
                } catch (error) {
                    console.warn(`Could not load floor plan for ${floor}:`, error);
                    document.getElementById('minimap').innerHTML = 
                        '<p style="color:white;padding:10px;text-align:center">Floor plan not available.</p>';
                }
            } // Closing brace for loadFloorPlan function

            // Function to clear all markers
            // Helper function to convert between coordinate systems
            function convertCoordinates(x, y, fromType, toType, imgWidth, imgHeight) {
                // Default dimensions if not provided
                const width = imgWidth || 600;
                const height = imgHeight || 600;
                
                // Convert to relative coordinates (percentage of image)
                let relX, relY;
                
                if (fromType === 'svg') {
                    // SVG coordinates are typically in the SVG's internal system
                    // Assuming the SVG viewbox or original dimensions are 600x600
                    relX = x / 600;
                    relY = y / 600;
                } else if (fromType === 'png') {
                    // PNG coordinates are in pixels from the top-left
                    relX = x / width;
                    relY = y / height;
                } else if (fromType === 'relative') {
                    // Already relative
                    relX = x;
                    relY = y;
                }
                
                // Convert from relative to target format
                if (toType === 'svg') {
                    return {
                        x: relX * 600,
                        y: relY * 600
                    };
                } else if (toType === 'png') {
                    return {
                        x: relX * width,
                        y: relY * height
                    };
                } else if (toType === 'leaflet') {
                    // For Leaflet, y=0 is bottom, not top
                    return {
                        x: relX,
                        y: 1 - relY // Invert Y for Leaflet
                    };
                } else {
                    // Return relative coordinates
                    return { x: relX, y: relY };
                }
            }

            function clearMarkers() {
                console.log('Clearing all markers...');
                if (markers) {
                    Object.values(markers).forEach(marker => {
                        try {
                            if (map && marker) {
                                map.removeLayer(marker);
                            }
                        } catch (e) {
                            console.warn('Error removing marker:', e);
                        }
                    });
                    markers = {}; // Reset markers object
                }
                activeMarker = null; // Reset active marker reference
            }
            
            function createMarkers(floor) {
                console.log(`Creating markers for floor: ${floor}`);
                // First, get the minimap container dimensions for relative positioning
                const minimapContainer = document.getElementById('minimap');
                const containerWidth = minimapContainer.clientWidth;
                const containerHeight = minimapContainer.clientHeight;
                
                // Clear any existing markers first
                clearMarkers();
                
                // We'll use DOM absolute positioning instead of Leaflet coordinates
                // This ensures perfect alignment regardless of the image format
                Object.keys(tourConfig.scenes).forEach(sceneId => {
                    const scene = tourConfig.scenes[sceneId];
                    if (scene.panorama && scene.panorama.includes(`/${floor}/`)) {
                        if (scene.map && scene.map.x && scene.map.y) {
                            // Get the original SVG coordinates
                            const svgX = parseFloat(scene.map.x);
                            const svgY = parseFloat(scene.map.y);
                            
                            console.log(`Scene ${sceneId}: Original SVG coords (${svgX}, ${svgY})`);
                            
                            // Determine if we're using PNG or SVG for positioning calculations
                            const isPNG = window.floorplanInfo && window.floorplanInfo.type === 'png';
                            let relX, relY;
                            
                            // Define reference dimensions for coordinate transformation
                            // SVG dimensions used as reference (update these if your SVG size changes)
                            const SVG_WIDTH = 600;  // Reference SVG width
                            const SVG_HEIGHT = 600; // Reference SVG height
                            
                            // Get actual image dimensions for better scaling
                            const imgWidth = map.imgWidth || SVG_WIDTH;
                            const imgHeight = map.imgHeight || SVG_HEIGHT;
                            
                            // Special calibration for specific points
                            if (sceneId === 'lcorr1') {
                                if (isPNG) {
                                    // Calibration specific for PNG
                                    relX = 0.48; 
                                    relY = 0.40;
                                } else {
                                    // SVG calibration
                                    relX = 0.48;
                                    relY = 0.40;
                                }
                                console.log(`Using calibrated ${isPNG ? 'PNG' : 'SVG'} position for ${sceneId}: (${relX}, ${relY})`);
                            } else if (sceneId === 'lcorr2') {
                                if (isPNG) {
                                    // Calibration specific for PNG
                                    relX = 0.58;
                                    relY = 0.40;
                                } else {
                                    // SVG calibration
                                    relX = 0.58;
                                    relY = 0.40;
                                }
                                console.log(`Using calibrated ${isPNG ? 'PNG' : 'SVG'} position for ${sceneId}: (${relX}, ${relY})`);
                            } else {
                                // For other points, use a calculation based on dimensions
                                if (isPNG) {
                                    // Adjust calculation for PNG
                                    // This assumes SVG coordinates can be mapped directly to PNG with scaling
                                    relX = svgX / SVG_WIDTH;
                                    relY = svgY / SVG_HEIGHT;
                                } else {
                                    // Standard SVG calculation
                                    relX = svgX / SVG_WIDTH;
                                    relY = svgY / SVG_HEIGHT;
                                }
                                console.log(`Using calculated position for ${sceneId} (${isPNG ? 'PNG' : 'SVG'}): (${relX}, ${relY}) from coords (${svgX}, ${svgY})`);
                            }
                            
                            // Create a custom icon for the marker with unique identifier
                            const isActive = sceneId === viewer.getScene();
                            const markerClass = `scene-marker-icon ${sceneId}-marker`;
                            const icon = L.divIcon({
                                className: isActive ? `${markerClass} active` : markerClass,
                                html: '', // Empty HTML content as we're using CSS for styling
                                iconSize: [14, 14], // Fixed size for all markers
                                iconAnchor: [7, 7]   // Center point of the marker
                            });
                            
                            // Calculate Leaflet coordinates from relative positions
                            const bounds = map.getBounds();
                            const mapWidth = bounds.getEast() - bounds.getWest();
                            const mapHeight = bounds.getNorth() - bounds.getSouth();
                            
                            // For Leaflet, we need to invert the Y coordinate since Leaflet's
                            // coordinate system has y=0 at the bottom, while images have y=0 at the top
                            const leafletX = bounds.getWest() + (relX * mapWidth);
                            const leafletY = bounds.getSouth() + ((1-relY) * mapHeight); // Invert Y
                            
                            console.log(`Scene ${sceneId}: Calculated Leaflet coords (${leafletX}, ${leafletY}) from rel position (${relX}, ${relY})`);
                            
                            // Create and add the marker to the map
                            const marker = L.marker([leafletY, leafletX], {
                                icon: icon,
                                title: scene.title || sceneId,
                                riseOnHover: true
                            }).addTo(map);
                            
                            // Add click event
                            marker.on('click', () => {
                                console.log(`Marker clicked: ${sceneId}`);
                                viewer.loadScene(sceneId);
                            });
                            
                            // Store marker reference
                            markers[sceneId] = marker;
                        }
                    }
                });
                
                // Update active marker
                const currentSceneId = viewer.getScene();
                updateActiveMarker(currentSceneId);
            }

            function updateActiveMarker(sceneId) {
                // Reset previous active marker if any
                if (activeMarker) {
                    // Remove active class from marker icon
                    const markerIcon = activeMarker.getElement();
                    if (markerIcon) {
                        markerIcon.classList.remove('active');
                        // Reset z-index
                        markerIcon.style.zIndex = '1000';
                    }
                }
                
                // Set new active marker
                const marker = markers[sceneId];
                if (marker) {
                    activeMarker = marker;
                    
                    // Add active class to marker icon
                    const markerIcon = marker.getElement();
                    if (markerIcon) {
                        markerIcon.classList.add('active');
                        // Ensure the active marker is on top of other markers
                        markerIcon.style.zIndex = '1001';
                    }
                    
                    // Note: bringToFront() is not working, using z-index instead
                    // No need to call marker.bringToFront() as we're setting z-index manually
                    
                    // Pan the map to center on the active marker if needed
                    // Use a slight delay to ensure smooth transition
                    setTimeout(() => {
                        if (map && marker) {
                            try {
                                map.panTo(marker.getLatLng());
                            } catch (e) {
                                console.warn('Error panning to marker:', e);
                            }
                        }
                    }, 100);
                    
                    console.log(`Active marker updated to scene: ${sceneId}`);
                }
            }

            loadTour();
        });
    </script>

</body>
</html>